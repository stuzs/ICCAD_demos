#!/usr/bin/env python
"""For demonstrating DC analysis of linear circuit using both 
Nodal Analysis(NA) and Modified Nodal Analysis(MNA) methods.
NumPy is used for matrix operation.
"""

# edited for github re-post in 03/27/2024

import sys
import numpy as np


def isnotGround(node_name):
    """Is the node_name not an alias of Ground?
    """
    return bool(node_name != '0' and node_name != 'GND')


class Component(object):
    """Component is a class, which has 4 class members for
       each circuit component: name, pNode, nNode and value
       ---
       + matrixFill() configures the nodal matrix for each component
    """

    def __init__(self, name, positiveNode, negativeNode, value):
        self.name = name
        self.pNode = positiveNode
        self.nNode = negativeNode
        self.value = value

    def matrixFill(self, G, B, vectorI, vectorE):
        """Fill matrices G and vectorI, according to self's value.
           If self is a voltage source, B and vectorE are filled.
        """
        # what if value is a complex number?
        value = float(self.value)

        # Why use 'try' here? Because '0' and GND' are not in nodeDict,
        # and that will cause an error. Using try can avoid this error.
        # Not good practice, but useful in showing try/except pair.
        try:
            nP = nodeDict[self.pNode]
        except KeyError:
            pass

        try:
            nN = nodeDict[self.nNode]
        except KeyError:
            pass

        if self.name.startswith('R'):  # Resistor handling
            if isnotGround(self.pNode) and isnotGround(self.nNode):
                G[nP][nP] += 1 / value
                G[nN][nN] += 1 / value
                G[nP][nN] -= 1 / value
                G[nN][nP] -= 1 / value
            elif isnotGround(self.pNode):
                G[nP][nP] += 1 / value
            elif isnotGround(self.nNode):
                G[nN][nN] += 1 / value

        if self.name.startswith('I'):  # Current source handling
            if isnotGround(self.pNode):
                vectorI[nP][0] -= value
            if isnotGround(self.nNode):
                vectorI[nN][0] += value

        if self.name.startswith('V'):  # Voltage source handling
            nV = int(vsrcDict[self.name])
            vectorE[nV][0] = value
            if isnotGround(self.pNode):
                B[nP][nV] = 1
            if isnotGround(self.nNode):
                B[nN][nV] = -1


# First, read in circuit file name in command line
if len(sys.argv) > 1:
    netlistFile = sys.argv[1]
    print("Input circuit file name for analyzing is: %s" % (netlistFile))
else:
    # use raw_input() in Python 2, but input() in Python 3
    netlistFile = input("Input circuit file name for analyzing: ")

with open(netlistFile) as netlist:
    # Second, create a component for each line, and store each
    # component into a list 'circuit', a holding place of all components.
    # As in SPICE, node names are all case-insensitive! (upper for all)
    circuit = []
    for line in netlist.readlines():
        # Parse the line into a word list
        wl = line.upper().strip().split()
        # Create a Component from this line, and add it to circuit
        # Ignore comments line, ignore line having less than 4 fields
        if len(wl) >= 4 and not wl[0].startswith(('*', '#')):
            circuit.append(Component(wl[0], wl[1], wl[2], wl[3]))

    # If any V source met, MNA must be used
    usingMNA = False
    for comp in circuit:
        if comp.name.startswith('V'):
            usingMNA = True
            break

    # Create two empty sets for holding node names & v-source names
    nodeSet = set()
    vsrcSet = set()

    # Next, record all node names and v-source names in the circuit
    for comp in circuit:
        if comp.name.startswith(('R', 'V', 'I')):
            nodeSet.add(comp.pNode)
            nodeSet.add(comp.nNode)
        if comp.name.startswith('V'):
            vsrcSet.add(comp.name)
    # All node names are now stored in nodeSet
    # All v-source names are now stored in vsrcSet

    # However, 0/GND are treated as the same node, not appearing in matrix
    if '0' in nodeSet:
        nodeSet.remove('0')
    if 'GND' in nodeSet:
        nodeSet.remove('GND')

    # Assign each node and v-source a unique number, beginning from 0
    # The unique numbers are stored in two Dictionaries{}
    # A list generated by a set is surely having unique members
    nodeList = list(nodeSet)
    vsrcList = list(vsrcSet)
    nodeDict = {x: nodeList.index(x) for x in nodeList}
    vsrcDict = {x: vsrcList.index(x) for x in vsrcList}

    # Take a look to the name<->number mapping in dictionary?
    #print(nodeDict)
    #print(vsrcDict)

    # Determine the dimensions N, M; i.e., how many nodes, v-sources?
    N = len(nodeDict)
    M = len(vsrcDict)

    # Set the final matrix equation, based on NumPy matrix commands
    #   G    B           VI
    # [        ] [X] = [    ]
    #   BT   D           VE
    # where BT is the transpose of B
    G = np.zeros([N, N])
    D = np.zeros([M, M])
    B = np.zeros([N, M])
    vectorI = np.zeros([N, 1])
    vectorE = np.zeros([M, 1])
    # And, what if we need all above matrices being complex?
    # NumPy supports complex number operations with such an ease

    # Now construct the nodal Matrix by looping over each component
    for comp in circuit:
        comp.matrixFill(G, B, vectorI, vectorE)

    # Take a look to these matrices?
    #print (G)
    #print (B)
    #print (vectorI)
    #print (vectorE)

    if not usingMNA:  # Ordinary NA used
        Result = np.dot(np.linalg.inv(G), vectorI)
    else:  # MNA must be used
        C = B.T
        A = np.vstack((np.hstack((G, B)), np.hstack((C, D))))
        vectorZ = np.vstack((vectorI, vectorE))
        Result = np.dot(np.linalg.inv(A), vectorZ)
    # hstack()/vstack() are useful NumPy features

    # Output the result below. Would you try to sort them?
    for node in nodeDict.keys():
        print("node %s: %.6fV" % (node, Result[nodeDict[node]]))

    if usingMNA:
        print("------")
        for vsrc in vsrcDict.keys():
            print("vsource %s: %.6fA" % (vsrc, Result[vsrcDict[vsrc] + N]))
