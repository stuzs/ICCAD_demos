#!/usr/bin/env python
'''This program is a command line entry to the AND2 standard cell
characterization example. It manages the tasks of cell characterization,
look-up table (LUT) generation, table looking-up and test circuit
validations through command line options, which are parsed by argparse
module. Descriptions of related files are in readme.md.
'''
import os
import sys
import argparse

# and2_lut_calc.py is generated by one option of this program
try:
    from and2_lut_calc import lookupAND2CellTiming
except ModuleNotFoundError:
    pass


def leave_prog(message: str, exit_code=1):
    """
    Leave the program with an exit value
    """
    if exit_code != 0:
        print(message, file=sys.stderr)
    else:
        print(message)
    sys.exit(exit_code)


# Some reserved file names for storing intermediate data
TRIAL_GATE_FILE = "trial_and2_sckt.spice"
WORK_GATE_FILE = "working_and2_sckt.spice"
SPICE_OUT_FILE = "working_batch_char_out.data"
# Reserved file name for data LUTS resulted by cell characterization
LUT_ARRAY_FILE = "working_and2_lut_array.py"


parser = argparse.ArgumentParser(
    description='%(prog)s: command line entry to AND2 cell \
    characterization demo',
    epilog='Find command usage examples in readme.md file\n')
parser.add_argument(
    '-v', '--version', action='version', version='%(prog)s 1.0')
parser.add_argument(
    '-t',  '--trial', action='store_true',
    help='trial SPICE run on one characterizing condition')
parser.add_argument(
    '-g',  '--generate', action='store_true',
    help='generate NLDM timing tables by SPICE batch runs')
parser.add_argument(
    '-w',  '--weakB',  action='store_true',
    help='use weak input pin-B AND2 cell in characterizing')
parser.add_argument(
    '-r',  '--report',  action='store_true',
    help='report characterization result status')
parser.add_argument(
    '-l',  action='store', nargs=2, metavar=('SLEW_IN', 'CAP_LOAD'),
    type=float, help='look up timings by 2 following inputs in (ns, fF)')
parser.add_argument(
    '-e',  '--evaluate',  action='store_true',
    help='evaluate timings of a 100-stages AND2 chain')
parser.add_argument(
    '-fc',  '--fcap', type=float,
    help="set chain's final stage load capacitance in fF")
parser.add_argument(
    '-ic',  '--icap', type=float,
    help="set chain's 10-gates interval load cap. in fF")

# read arguments
args = parser.parse_args()

# execution options '-t', '-g', '-r', '-l', '-e' are mutually exclusive
EXEC_ACTIONS = 0
for arg_val in (args.trial, args.generate, args.report,
                args.l, args.evaluate):
    if arg_val:
        EXEC_ACTIONS += 1
if EXEC_ACTIONS > 1:
    leave_prog("Too many execution options in one command")
elif EXEC_ACTIONS == 0:
    leave_prog("No real actions taken")

# options '-w' only have effects when executing '-g' or '-t'
if args.weakB:
    if not (args.generate or args.trial):
        leave_prog("Wrong set -w or --weakB option")

# options '-fc' and '-ic' only have effects when executing '-e'
ARG_FCAP = 40  # the default value of final stage cap.
ARG_ICAP = 10  # the default value of 10-gates interval cap.
# args.fcap/icap maybe both set as a float(but may equal to 0.0)
if args.fcap is not None:
    if not args.evaluate:
        leave_prog("Wrong set -fc or -fcap option")
    ARG_FCAP = args.fcap
    if ARG_FCAP < 0.0:
        leave_prog(str(ARG_FCAP) +
                   ": final stage load capacitance cannot be negative")
if args.icap is not None:
    if not args.evaluate:
        leave_prog("Wrong set -ic or -icap option")
    ARG_ICAP = args.icap
    if ARG_ICAP < 0.0:
        leave_prog(str(ARG_ICAP) +
                   ": interval stage load capacitance cannot be negative")

# options '-l' must be followed by two numbers standing for slew and cap
if args.l:
    if args.l[0] <= 0.0:
        leave_prog(str(args.l[0]) +
                   ": input slew could not be zero or negative")
    if args.l[1] < 0.0:
        leave_prog(str(args.l[1]) +
                   ": load cap could not be negative")

if args.trial:
    if not args.weakB:
        ret_code = os.system(
            "echo .include ./and2_sckt.spice >" + TRIAL_GATE_FILE)
    else:
        ret_code = os.system(
            "echo .include ./and2_weakB_sckt.spice >" + TRIAL_GATE_FILE)
    if ret_code:
        leave_prog("Wrong trial gate file creation")

    ret_code = os.system("ngspice and2_trial_char.spice")
    if ret_code:
        leave_prog("Wrong trial characterization run")
    else:
        leave_prog("Trial characterization run OK", exit_code=0)

if args.generate:
    if not args.weakB:
        ret_code = os.system(
            "echo .include ./and2_sckt.spice >" + WORK_GATE_FILE)
    else:
        ret_code = os.system(
            "echo .include ./and2_weakB_sckt.spice >" + WORK_GATE_FILE)
    if ret_code:
        leave_prog("Wrong working gate file creation")
    ret_code = os.system("ngspice and2_batch_char.spice | tee "
                         + SPICE_OUT_FILE)
    if ret_code:
        leave_prog("Wrong characterization batch run")
    else:
        # assume calling BASH program won't fail
        if args.weakB:
            os.system("bash and2_gentab.bash weakB")  # add a weakB arg
        else:
            os.system("bash and2_gentab.bash")
        os.system("bash and2_gentab.second.bash >" + LUT_ARRAY_FILE)
        leave_prog("Characterization batch run OK", exit_code=0)

# After executing '-g' option, the NLDM 2D-LUTs are actually stored in
# a Python file 'working_and2_lut_array.py'.
# Check the time order of files when running '-r' option, make sure the
# LUT array file is the newest among them,
#     working_and2_lut_array.py,
#     working_batch_char_out.data,
#     working_and2_sckt.spice
if args.report:
    if os.path.isfile(LUT_ARRAY_FILE) and \
            os.path.isfile(SPICE_OUT_FILE) and \
            os.path.isfile(WORK_GATE_FILE):
        if os.path.getmtime(LUT_ARRAY_FILE) > \
                os.path.getmtime(SPICE_OUT_FILE) and \
                os.path.getmtime(SPICE_OUT_FILE) > \
                os.path.getmtime(WORK_GATE_FILE):
            with open(WORK_GATE_FILE) as f:
                line = f.readline()
                if line == ".include ./and2_weakB_sckt.spice\n":
                    leave_prog(LUT_ARRAY_FILE +
                               " (weak pin B) is generated with " +
                               "correct file order", exit_code=0)
                elif line == ".include ./and2_sckt.spice\n":
                    leave_prog(LUT_ARRAY_FILE +
                               " (normal pin B) is generated with " +
                               "correct file order", exit_code=0)
                else:
                    leave_prog(WORK_GATE_FILE +
                               " is not in correct format")
        else:
            leave_prog(LUT_ARRAY_FILE + " may not be the newest")
    else:
        leave_prog(LUT_ARRAY_FILE +
                   " may not be generated by correct file setting")

# '-l' returns timings from all LUTs
timing_type_name_dict = {
    (True, True, True):    "Output Rising Transition, Ain:  ",
    (True, True, False):   "Output Rising Transition, Bin:  ",
    (True, False, True):   "Output Falling Transition, Ain: ",
    (True, False, False):  "Output Falling Transition, Bin: ",
    (False, True, True):   "Rising Propagation Delay, Ain:  ",
    (False, True, False):  "Rising Propagation Delay, Bin:  ",
    (False, False, True):  "Falling Propagation Delay, Ain  ",
    (False, False, False): "Falling Propagation Delay, Bin: ",
}

if args.l:
    for trans_type in (True, False):
        for rise_type in (True, False):
            for pinA_type in (True, False):
                result = lookupAND2CellTiming(
                    args.l[0]*1e-9, args.l[1]*1e-15, trans_type, rise_type,
                    pinA_type)
                print(timing_type_name_dict.get(
                      (trans_type, rise_type, pinA_type)), result)

# '-e' evaluates timings of the 100 gates linked chain
# the results here can be compared with the output of SPICE simulation
# on 'and2_chain.spice'
if args.evaluate:
    ret_code = os.system(
        "python chain_test.py " + str(ARG_FCAP * 1e-15)
        + " " + str(ARG_ICAP * 1e-15))
    if ret_code:
        leave_prog(
            "Problem in calling chain_test.py to evaluate the chain",
            ret_code)
